  -- draw the floor using Y based raycasting, scan the screen from top to bottom
  for y = 0, love.graphics.getHeight() - 1 do
    -- rayDir for leftmost ray (x = 0) and rightmost ray (x = w)
    local rayDirX0 = Player.facing.x - Player.camPlane.x
    local rayDirY0 = Player.facing.y - Player.camPlane.y
    local rayDirX1 = Player.facing.x + Player.camPlane.x
    local rayDirY1 = Player.facing.y + Player.camPlane.y

    -- Current y position compared to the center of the screen (the horizon)
    local p = y - love.graphics.getHeight() / 2

    -- Vertical position of the camera
    local posZ = 0.5 * love.graphics.getHeight()

    -- Horizontal distance from the camera to the floor for the current row
    local rowDistance = posZ / p
    local light = lume.clamp(1 / (rowDistance * rowDistance), 0, 1)
    light = light * 0.93 + 0.03 -- make it brighter

    local floorStepX = rowDistance * (rayDirX1 - rayDirX0) / love.graphics.getWidth()
    local floorStepY = rowDistance * (rayDirY1 - rayDirY0) / love.graphics.getWidth()

    local floorX = Player.pos.x + rowDistance * rayDirX0
    local floorY = Player.pos.y + rowDistance * rayDirY0

    for x = 0, love.graphics.getWidth() - 1 do
      -- Get the texture coordinates for the floor texture
      local tx = tileWidth * utils.frac(floorX)
      local ty = tileHeight * utils.frac(floorY)

      floorX = floorX + floorStepX
      floorY = floorY + floorStepY

      if tx > 0 and tx < tileWidth and ty > 0 and ty < tileHeight then
        local pixF = FloorRawData[math.floor(ty)][math.floor(tx)]
        local pixC = CeilRawData[math.floor(ty)][math.floor(tx)]
        BGImageData:setPixel(x, y, pixF[1] * light, pixF[2] * light, pixF[3] * light, 1)
        BGImageData:setPixel(x, love.graphics.getHeight() - y - 1, pixC[1] * light, pixC[2] * light, pixC[3] * light, 1)
      end
    end
  end

  -- draw the floor texture
  BGImage = love.graphics.newImage(BGImageData)
  love.graphics.draw(BGImage, 0, 0, 0)
